import{a9 as N,M as E,J as _,b2 as F,b3 as R,Y as q,b4 as j,b as L,b5 as W,$ as z,a2 as D,a6 as G,a4 as K,a5 as X,e as O,T as B,ao as H,b6 as w,aq as U,E as Q,R as J}from"./index-WPyB0dpY.js";import"./index-VELz1aW8.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";const C=new WeakMap;function $(v){const t=v.getVertexBuffers();if(!t)return null;let e=C.get(v);if(!e)e=new Map,C.set(v,e);else{let o=!1;for(const s in t)if(!e.has(s)){o=!0;break}if(!o)return e}for(const o in t){const s=t[o];if(s){const i=s.byteOffset,n=s.byteStride,a=s.type;e.set(o,{offset:i,stride:n,type:a})}}return e}function Y(v,t){t.forEach((e,o)=>{const s=`vp_${o}_info`;v.setFloat3(s,e.offset,e.stride,e.type)})}const P={effect:null,subMesh:null};class x extends N{constructor(t,e,o,s={},i=!0){super(t,e,i),this._textures={},this._internalTextures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new E,this._cachedWorldViewProjectionMatrix=new E,this._multiview=!1,this._vertexPullingMetadata=null,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=o,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...s}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){this._options.uniforms.indexOf(t)===-1&&this._options.uniforms.push(t)}setTexture(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._textures[t]=e,this}setInternalTexture(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._internalTextures[t]=e,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=e,this}setExternalTexture(t,e){return this._options.externalTextures.indexOf(t)===-1&&this._options.externalTextures.push(t),this._externalTextures[t]=e,this}setFloat(t,e){return this._checkUniform(t),this._floats[t]=e,this}setInt(t,e){return this._checkUniform(t),this._ints[t]=e,this}setUInt(t,e){return this._checkUniform(t),this._uints[t]=e,this}setFloats(t,e){return this._checkUniform(t),this._floatsArrays[t]=e,this}setColor3(t,e){return this._checkUniform(t),this._colors3[t]=e,this}setColor3Array(t,e){return this._checkUniform(t),this._colors3Arrays[t]=e.reduce((o,s)=>(o.push(s.r,s.g,s.b),o),[]),this}setColor4(t,e){return this._checkUniform(t),this._colors4[t]=e,this}setColor4Array(t,e){return this._checkUniform(t),this._colors4Arrays[t]=e.reduce((o,s)=>(o.push(s.r,s.g,s.b,s.a),o),[]),this}setVector2(t,e){return this._checkUniform(t),this._vectors2[t]=e,this}setVector3(t,e){return this._checkUniform(t),this._vectors3[t]=e,this}setVector4(t,e){return this._checkUniform(t),this._vectors4[t]=e,this}setQuaternion(t,e){return this._checkUniform(t),this._quaternions[t]=e,this}setQuaternionArray(t,e){return this._checkUniform(t),this._quaternionsArrays[t]=e.reduce((o,s)=>(s.toArray(o,o.length),o),[]),this}setMatrix(t,e){return this._checkUniform(t),this._matrices[t]=e,this}setMatrices(t,e){this._checkUniform(t);const o=new Float32Array(e.length*16);for(let s=0;s<e.length;s++)e[s].copyToArray(o,s*16);return this._matrixArrays[t]=o,this}setMatrix3x3(t,e){return this._checkUniform(t),this._matrices3x3[t]=e,this}setMatrix2x2(t,e){return this._checkUniform(t),this._matrices2x2[t]=e,this}setArray2(t,e){return this._checkUniform(t),this._vectors2Arrays[t]=e,this}setArray3(t,e){return this._checkUniform(t),this._vectors3Arrays[t]=e,this}setArray4(t,e){return this._checkUniform(t),this._vectors4Arrays[t]=e,this}setUniformBuffer(t,e){return this._options.uniformBuffers.indexOf(t)===-1&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=e,this}setTextureSampler(t,e){return this._options.samplerObjects.indexOf(t)===-1&&this._options.samplerObjects.push(t),this._textureSamplers[t]=e,this}setStorageBuffer(t,e){return this._options.storageBuffers.indexOf(t)===-1&&this._options.storageBuffers.push(t),this._storageBuffers[t]=e,this}setDefine(t,e){const o=t.trimEnd()+" ",s=this.options.defines.findIndex(i=>i===t||i.startsWith(o));return s>=0&&this.options.defines.splice(s,1),(typeof e!="boolean"||e)&&this.options.defines.push(o+e),this}isReadyForSubMesh(t,e,o){return this.isReady(t,o,e)}isReady(t,e,o){const s=o&&this._storeEffectOnSubMeshes;if(this.isFrozen){const h=s?o._drawWrapper:this._drawWrapper;if(h.effect&&h._wasPreviouslyReady&&h._wasPreviouslyUsingInstances===e)return!0}const i=this.getScene(),n=i.getEngine(),a=[],f=[];let c=null,T=this._shaderPath,r=this._options.uniforms,u=this._options.uniformBuffers,p=this._options.samplers;n.getCaps().multiview&&i.activeCamera&&i.activeCamera.outputRenderTarget&&i.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,a.push("#define MULTIVIEW"),r.indexOf("viewProjection")!==-1&&r.indexOf("viewProjectionR")===-1&&r.push("viewProjectionR"));for(let h=0;h<this._options.defines.length;h++){const g=this._options.defines[h].indexOf("#define")===0?this._options.defines[h]:`#define ${this._options.defines[h]}`;a.push(g)}for(let h=0;h<this._options.attributes.length;h++)f.push(this._options.attributes[h]);if(t&&t.isVerticesDataPresent(_.ColorKind)&&(f.indexOf(_.ColorKind)===-1&&f.push(_.ColorKind),a.push("#define VERTEXCOLOR")),e&&(a.push("#define INSTANCES"),F(f,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(a.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(_.ColorInstanceKind)&&(f.push(_.ColorInstanceKind),a.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){f.push(_.MatricesIndicesKind),f.push(_.MatricesWeightsKind),t.numBoneInfluencers>4&&(f.push(_.MatricesIndicesExtraKind),f.push(_.MatricesWeightsExtraKind));const h=t.skeleton;a.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),c=new Q,c.addCPUSkinningFallback(0,t),h.isUsingTextureForMatrices?(a.push("#define BONETEXTURE"),r.indexOf("boneTextureWidth")===-1&&r.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(a.push("#define BonesPerMesh "+(h.bones.length+1)),r.indexOf("mBones")===-1&&r.push("mBones"))}else a.push("#define NUM_BONE_INFLUENCERS 0");let d=0;const y=t?t.morphTargetManager:null;if(y){const h=a.indexOf("#define UV1")!==-1,g=a.indexOf("#define UV2")!==-1,k=a.indexOf("#define TANGENT")!==-1,M=a.indexOf("#define NORMAL")!==-1,I=a.indexOf("#define VERTEXCOLOR")!==-1;d=R(y,a,f,t,!0,M,k,h,g,I),y.isUsingTextureForTargets&&(r.indexOf("morphTargetTextureIndices")===-1&&r.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),d>0&&(r=r.slice(),r.push("morphTargetInfluences"),r.push("morphTargetCount"),r.push("morphTargetTextureInfo"),r.push("morphTargetTextureIndices"))}else a.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const h=t.bakedVertexAnimationManager;h&&h.isEnabled&&(a.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),r.indexOf("bakedVertexAnimationSettings")===-1&&r.push("bakedVertexAnimationSettings"),r.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&r.push("bakedVertexAnimationTextureSizeInverted"),r.indexOf("bakedVertexAnimationTime")===-1&&r.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture"),e&&f.push("bakedVertexAnimationSettingsInstanced"))}for(const h in this._textures)if(!this._textures[h].isReady())return!1;for(const h in this._internalTextures)if(!this._internalTextures[h].isReady)return!1;t&&this.needAlphaTestingForMesh(t)&&a.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(q(r),j(this,i,a)),i.fogEnabled&&t?.applyFog&&i.fogMode!==L.FOGMODE_NONE&&(a.push("#define FOG"),r.indexOf("view")===-1&&r.push("view"),r.indexOf("vFogInfos")===-1&&r.push("vFogInfos"),r.indexOf("vFogColor")===-1&&r.push("vFogColor")),this._useLogarithmicDepth&&(a.push("#define LOGARITHMICDEPTH"),r.indexOf("logarithmicDepthConstant")===-1&&r.push("logarithmicDepthConstant"));const l=o?o.getRenderingMesh():t;if(l&&this.useVertexPulling){const h=l.geometry;h&&(this._vertexPullingMetadata=$(h),this._vertexPullingMetadata&&this._vertexPullingMetadata.forEach((k,M)=>{r.push(`vp_${M}_info`)})),a.push("#define USE_VERTEX_PULLING");const g=l.geometry?.getIndexBuffer();g&&!l.isUnIndexed&&(a.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),g.is32Bits&&a.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}this.customShaderNameResolve&&(r=r.slice(),u=u.slice(),p=p.slice(),T=this.customShaderNameResolve(this.name,r,u,p,a,f));const A=s?o._getDrawWrapper(void 0,!0):this._drawWrapper,S=A?.effect??null,V=A?.defines??null,b=a.join(`
`);let m=S;return V!==b&&(m=n.createEffect(T,{attributes:f,uniformsNames:r,uniformBuffersNames:u,samplers:p,defines:b,fallbacks:c,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:d},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},n),s?o.setEffect(m,b,this._materialContext):A&&A.setEffect(m,b),this._onEffectCreatedObservable&&(P.effect=m,P.subMesh=o??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(P))),A._wasPreviouslyUsingInstances=!!e,m?.isReady()?(S!==m&&i.resetCachedMaterial(),A._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(t,e){const o=e??this.getEffect();if(!o)return;const s=this._options.uniforms;s.indexOf("world")!==-1&&o.setMatrix("world",t);const i=this.getScene();s.indexOf("worldView")!==-1&&(t.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),o.setMatrix("worldView",this._cachedWorldViewMatrix)),s.indexOf("worldViewProjection")!==-1&&(t.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),o.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),s.indexOf("view")!==-1&&o.setMatrix("view",i.getViewMatrix())}bindForSubMesh(t,e,o){this.bind(t,e,o._drawWrapperOverride?.effect,o)}bind(t,e,o,s){const i=s&&this._storeEffectOnSubMeshes,n=o??(i?s.effect:this.getEffect());if(!n)return;const a=this.getScene();this._activeEffect=n,this.bindOnlyWorldMatrix(t,o);const f=this._options.uniformBuffers;let c=!1;if(n&&f&&f.length>0&&a.getEngine().supportsUniformBuffers)for(let r=0;r<f.length;++r)switch(f[r]){case"Mesh":e&&(e.getMeshUniformBuffer().bindToEffect(n,"Mesh"),e.transferToEffect(t));break;case"Scene":W(n,a.getSceneUniformBuffer()),a.finalizeSceneUbo(),c=!0;break}const T=e&&i?this._mustRebind(a,n,s,e.visibility):a.getCachedMaterial()!==this;if(n&&T){!c&&this._options.uniforms.indexOf("view")!==-1&&n.setMatrix("view",a.getViewMatrix()),!c&&this._options.uniforms.indexOf("projection")!==-1&&n.setMatrix("projection",a.getProjectionMatrix()),!c&&this._options.uniforms.indexOf("viewProjection")!==-1&&(n.setMatrix("viewProjection",a.getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",a._transformMatrixR)),a.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&n.setVector3("cameraPosition",a.activeCamera.globalPosition),z(e,n),D(n,this,a),this._vertexPullingMetadata&&Y(n,this._vertexPullingMetadata),this._useLogarithmicDepth&&G(i?s.materialDefines:n.defines,n,a),e&&K(a,e,n);let r;for(r in this._textures)n.setTexture(r,this._textures[r]);for(r in this._internalTextures)n._bindTexture(r,this._internalTextures[r]);for(r in this._textureArrays)n.setTextureArray(r,this._textureArrays[r]);for(r in this._ints)n.setInt(r,this._ints[r]);for(r in this._uints)n.setUInt(r,this._uints[r]);for(r in this._floats)n.setFloat(r,this._floats[r]);for(r in this._floatsArrays)n.setArray(r,this._floatsArrays[r]);for(r in this._colors3)n.setColor3(r,this._colors3[r]);for(r in this._colors3Arrays)n.setArray3(r,this._colors3Arrays[r]);for(r in this._colors4){const l=this._colors4[r];n.setFloat4(r,l.r,l.g,l.b,l.a)}for(r in this._colors4Arrays)n.setArray4(r,this._colors4Arrays[r]);for(r in this._vectors2)n.setVector2(r,this._vectors2[r]);for(r in this._vectors3)n.setVector3(r,this._vectors3[r]);for(r in this._vectors4)n.setVector4(r,this._vectors4[r]);for(r in this._quaternions)n.setQuaternion(r,this._quaternions[r]);for(r in this._matrices)n.setMatrix(r,this._matrices[r]);for(r in this._matrixArrays)n.setMatrices(r,this._matrixArrays[r]);for(r in this._matrices3x3)n.setMatrix3x3(r,this._matrices3x3[r]);for(r in this._matrices2x2)n.setMatrix2x2(r,this._matrices2x2[r]);for(r in this._vectors2Arrays)n.setArray2(r,this._vectors2Arrays[r]);for(r in this._vectors3Arrays)n.setArray3(r,this._vectors3Arrays[r]);for(r in this._vectors4Arrays)n.setArray4(r,this._vectors4Arrays[r]);for(r in this._quaternionsArrays)n.setArray4(r,this._quaternionsArrays[r]);for(r in this._uniformBuffers){const l=this._uniformBuffers[r].getBuffer();l&&n.bindUniformBuffer(l,r)}const u=a.getEngine(),p=u.setExternalTexture;if(p)for(r in this._externalTextures)p.call(u,r,this._externalTextures[r]);const d=u.setTextureSampler;if(d)for(r in this._textureSamplers)d.call(u,r,this._textureSamplers[r]);const y=u.setStorageBuffer;if(y)for(r in this._storageBuffers)y.call(u,r,this._storageBuffers[r])}if(n&&e&&(T||!this.isFrozen)){X(e,n),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(n);const r=e.bakedVertexAnimationManager;if(r&&r.isEnabled){const u=i?s._drawWrapper:this._drawWrapper;e.bakedVertexAnimationManager?.bind(n,!!u._wasPreviouslyUsingInstances)}}this._afterBind(e,n,s)}getActiveTextures(){const t=super.getActiveTextures();for(const e in this._textures)t.push(this._textures[e]);for(const e in this._textureArrays){const o=this._textureArrays[e];for(let s=0;s<o.length;s++)t.push(o[s])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const o in this._textures)if(this._textures[o]===t)return!0;const e=t.getInternalTexture();for(const o in this._internalTextures)if(this._internalTextures[o]===e)return!0;for(const o in this._textureArrays){const s=this._textureArrays[o];for(let i=0;i<s.length;i++)if(s[i]===t)return!0}return!1}clone(t){const e=O.Clone(()=>new x(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);e.name=t,e.id=t,typeof e._shaderPath=="object"&&(e._shaderPath={...e._shaderPath}),this._options={...this._options};const o=Object.keys(this._options);for(const s of o){const i=this._options[s];Array.isArray(i)&&(this._options[s]=i.slice(0))}this.stencil.copyTo(e.stencil);for(const s in this._textures)e.setTexture(s,this._textures[s]);for(const s in this._internalTextures)e.setInternalTexture(s,this._internalTextures[s]);for(const s in this._textureArrays)e.setTextureArray(s,this._textureArrays[s]);for(const s in this._externalTextures)e.setExternalTexture(s,this._externalTextures[s]);for(const s in this._ints)e.setInt(s,this._ints[s]);for(const s in this._uints)e.setUInt(s,this._uints[s]);for(const s in this._floats)e.setFloat(s,this._floats[s]);for(const s in this._floatsArrays)e.setFloats(s,this._floatsArrays[s]);for(const s in this._colors3)e.setColor3(s,this._colors3[s]);for(const s in this._colors3Arrays)e._colors3Arrays[s]=this._colors3Arrays[s];for(const s in this._colors4)e.setColor4(s,this._colors4[s]);for(const s in this._colors4Arrays)e._colors4Arrays[s]=this._colors4Arrays[s];for(const s in this._vectors2)e.setVector2(s,this._vectors2[s]);for(const s in this._vectors3)e.setVector3(s,this._vectors3[s]);for(const s in this._vectors4)e.setVector4(s,this._vectors4[s]);for(const s in this._quaternions)e.setQuaternion(s,this._quaternions[s]);for(const s in this._quaternionsArrays)e._quaternionsArrays[s]=this._quaternionsArrays[s];for(const s in this._matrices)e.setMatrix(s,this._matrices[s]);for(const s in this._matrixArrays)e._matrixArrays[s]=this._matrixArrays[s].slice();for(const s in this._matrices3x3)e.setMatrix3x3(s,this._matrices3x3[s]);for(const s in this._matrices2x2)e.setMatrix2x2(s,this._matrices2x2[s]);for(const s in this._vectors2Arrays)e.setArray2(s,this._vectors2Arrays[s]);for(const s in this._vectors3Arrays)e.setArray3(s,this._vectors3Arrays[s]);for(const s in this._vectors4Arrays)e.setArray4(s,this._vectors4Arrays[s]);for(const s in this._uniformBuffers)e.setUniformBuffer(s,this._uniformBuffers[s]);for(const s in this._textureSamplers)e.setTextureSampler(s,this._textureSamplers[s]);for(const s in this._storageBuffers)e.setStorageBuffer(s,this._storageBuffers[s]);return e}dispose(t,e,o){if(e){let s;for(s in this._textures)this._textures[s].dispose();for(s in this._internalTextures)this._internalTextures[s].dispose();for(s in this._textureArrays){const i=this._textureArrays[s];for(let n=0;n<i.length;n++)i[n].dispose()}}this._textures={},this._internalTextures={},super.dispose(t,e,o)}serialize(){const t=O.Serialize(this);t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let e;t.stencil=this.stencil.serialize(),t.textures={};for(e in this._textures)t.textures[e]=this._textures[e].serialize();t.textureArrays={};for(e in this._textureArrays){t.textureArrays[e]=[];const o=this._textureArrays[e];for(let s=0;s<o.length;s++)t.textureArrays[e].push(o[s].serialize())}t.ints={};for(e in this._ints)t.ints[e]=this._ints[e];t.uints={};for(e in this._uints)t.uints[e]=this._uints[e];t.floats={};for(e in this._floats)t.floats[e]=this._floats[e];t.floatsArrays={};for(e in this._floatsArrays)t.floatsArrays[e]=this._floatsArrays[e];t.colors3={};for(e in this._colors3){const o=this._colors3[e];t.colors3[e]=[o.r,o.g,o.b]}t.colors3Arrays={};for(e in this._colors3Arrays)t.colors3Arrays[e]=this._colors3Arrays[e];t.colors4={};for(e in this._colors4){const o=this._colors4[e];t.colors4[e]=[o.r,o.g,o.b,o.a]}t.colors4Arrays={};for(e in this._colors4Arrays)t.colors4Arrays[e]=this._colors4Arrays[e];t.vectors2={};for(e in this._vectors2){const o=this._vectors2[e];t.vectors2[e]=[o.x,o.y]}t.vectors3={};for(e in this._vectors3){const o=this._vectors3[e];t.vectors3[e]=[o.x,o.y,o.z]}t.vectors4={};for(e in this._vectors4){const o=this._vectors4[e];t.vectors4[e]=[o.x,o.y,o.z,o.w]}t.quaternions={};for(e in this._quaternions)t.quaternions[e]=this._quaternions[e].asArray();t.matrices={};for(e in this._matrices)t.matrices[e]=this._matrices[e].asArray();t.matrixArray={};for(e in this._matrixArrays)t.matrixArray[e]=this._matrixArrays[e];t.matrices3x3={};for(e in this._matrices3x3)t.matrices3x3[e]=this._matrices3x3[e];t.matrices2x2={};for(e in this._matrices2x2)t.matrices2x2[e]=this._matrices2x2[e];t.vectors2Arrays={};for(e in this._vectors2Arrays)t.vectors2Arrays[e]=this._vectors2Arrays[e];t.vectors3Arrays={};for(e in this._vectors3Arrays)t.vectors3Arrays[e]=this._vectors3Arrays[e];t.vectors4Arrays={};for(e in this._vectors4Arrays)t.vectors4Arrays[e]=this._vectors4Arrays[e];t.quaternionsArrays={};for(e in this._quaternionsArrays)t.quaternionsArrays[e]=this._quaternionsArrays[e];return t}static Parse(t,e,o){const s=O.Parse(()=>new x(t.name,e,t.shaderPath,t.options,t.storeEffectOnSubMeshes),t,e,o);let i;t.stencil&&s.stencil.parse(t.stencil,e,o);for(i in t.textures)s.setTexture(i,B.Parse(t.textures[i],e,o));for(i in t.textureArrays){const n=t.textureArrays[i],a=[];for(let f=0;f<n.length;f++)a.push(B.Parse(n[f],e,o));s.setTextureArray(i,a)}for(i in t.ints)s.setInt(i,t.ints[i]);for(i in t.uints)s.setUInt(i,t.uints[i]);for(i in t.floats)s.setFloat(i,t.floats[i]);for(i in t.floatsArrays)s.setFloats(i,t.floatsArrays[i]);for(i in t.colors3){const n=t.colors3[i];s.setColor3(i,{r:n[0],g:n[1],b:n[2]})}for(i in t.colors3Arrays){const n=t.colors3Arrays[i].reduce((a,f,c)=>(c%3===0?a.push([f]):a[a.length-1].push(f),a),[]).map(a=>({r:a[0],g:a[1],b:a[2]}));s.setColor3Array(i,n)}for(i in t.colors4){const n=t.colors4[i];s.setColor4(i,{r:n[0],g:n[1],b:n[2],a:n[3]})}for(i in t.colors4Arrays){const n=t.colors4Arrays[i].reduce((a,f,c)=>(c%4===0?a.push([f]):a[a.length-1].push(f),a),[]).map(a=>({r:a[0],g:a[1],b:a[2],a:a[3]}));s.setColor4Array(i,n)}for(i in t.vectors2){const n=t.vectors2[i];s.setVector2(i,{x:n[0],y:n[1]})}for(i in t.vectors3){const n=t.vectors3[i];s.setVector3(i,{x:n[0],y:n[1],z:n[2]})}for(i in t.vectors4){const n=t.vectors4[i];s.setVector4(i,{x:n[0],y:n[1],z:n[2],w:n[3]})}for(i in t.quaternions)s.setQuaternion(i,H.FromArray(t.quaternions[i]));for(i in t.matrices)s.setMatrix(i,E.FromArray(t.matrices[i]));for(i in t.matrixArray)s._matrixArrays[i]=new Float32Array(t.matrixArray[i]);for(i in t.matrices3x3)s.setMatrix3x3(i,t.matrices3x3[i]);for(i in t.matrices2x2)s.setMatrix2x2(i,t.matrices2x2[i]);for(i in t.vectors2Arrays)s.setArray2(i,t.vectors2Arrays[i]);for(i in t.vectors3Arrays)s.setArray3(i,t.vectors3Arrays[i]);for(i in t.vectors4Arrays)s.setArray4(i,t.vectors4Arrays[i]);for(i in t.quaternionsArrays)s.setArray4(i,t.quaternionsArrays[i]);return s}static async ParseFromFileAsync(t,e,o,s=""){return await new Promise((i,n)=>{const a=new w;a.addEventListener("readystatechange",()=>{if(a.readyState==4)if(a.status==200){const f=JSON.parse(a.responseText),c=this.Parse(f,o||U.LastCreatedScene,s);t&&(c.name=t),i(c)}else n("Unable to load the ShaderMaterial")}),a.open("GET",e),a.send()})}static async ParseFromSnippetAsync(t,e,o=""){return await new Promise((s,i)=>{const n=new w;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const a=JSON.parse(JSON.parse(n.responseText).jsonPayload),f=JSON.parse(a.shaderMaterial),c=this.Parse(f,e||U.LastCreatedScene,o);c.snippetId=t,s(c)}else i("Unable to load the snippet "+t)}),n.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),n.send()})}}x.SnippetUrl="https://snippet.babylonjs.com";x.CreateFromSnippetAsync=x.ParseFromSnippetAsync;J("BABYLON.ShaderMaterial",x);export{x as ShaderMaterial};
