import{bk as y,aI as _,V as n,M as L,an as w,_ as b,s as A,R as v,bl as C,C as p,aG as P,aH as S}from"./index-WPyB0dpY.js";import{a as T}from"./objectModelMapping-B0ewMN_K.js";import{ArrayItem as m,GLTFLoader as g}from"./glTFLoader-BEfLAtlo.js";import"./index-VELz1aW8.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./bone-CoxiKvzQ.js";import"./skeleton-ByQ-bour.js";import"./rawTexture-Bg4I7d5Y.js";import"./assetContainer-CH9OIjaK.js";w.AddNodeConstructor("Light_Type_0",(l,t)=>()=>new c(l,n.Zero(),t));class c extends y{get shadowAngle(){return this._shadowAngle}set shadowAngle(t){this._shadowAngle=t,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(t){const i=this.needCube();if(this._direction=t,this.needCube()!==i&&this._shadowGenerators){const e=this._shadowGenerators.values();for(let r=e.next();r.done!==!0;r=e.next())r.value.recreateShadowMap()}}constructor(t,i,e,r){super(t,e,r),this._shadowAngle=Math.PI/2,this.position=i}getClassName(){return"PointLight"}getTypeID(){return _.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(t){if(this.direction)return super.getShadowDirection(t);switch(t){case 0:return new n(1,0,0);case 1:return new n(-1,0,0);case 2:return new n(0,-1,0);case 3:return new n(0,1,0);case 4:return new n(0,0,1);case 5:return new n(0,0,-1)}return n.Zero()}_setDefaultShadowProjectionMatrix(t,i,e){const r=this.getScene().activeCamera,d=this.getDepthMinZ(r),a=this.getDepthMaxZ(r),o=this.getScene().getEngine().useReverseDepthBuffer;L.PerspectiveFovLHToRef(this.shadowAngle,1,o?a:d,o?d:a,t,!0,this._scene.getEngine().isNDCHalfZRange,void 0,o)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(t,i){const e=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x-e.x,this.transformedPosition.y-e.y,this.transformedPosition.z-e.z,0,i):this._uniformBuffer.updateFloat4("vLightData",this.position.x-e.x,this.position.y-e.y,this.position.z-e.z,0,i),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,i),this}transferToNodeMaterialEffect(t,i){const e=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?t.setFloat3(i,this.transformedPosition.x-e.x,this.transformedPosition.y-e.y,this.transformedPosition.z-e.z):t.setFloat3(i,this.position.x-e.x,this.position.y-e.y,this.position.z-e.z),this}prepareLightSpecificDefines(t,i){t["POINTLIGHT"+i]=!0}}b([A()],c.prototype,"shadowAngle",null);v("BABYLON.PointLight",c);const f="KHR_lights_punctual";class x{constructor(t){this.name=f,this._loader=t,this.enabled=this._loader.isExtensionUsed(f)}dispose(){this._loader=null,delete this._lights}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const i=t[this.name];this._lights=i.lights,m.Assign(this._lights)}}loadNodeAsync(t,i,e){return g.LoadExtensionAsync(t,i,this.name,async(r,d)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(t,i,a=>{let o;const s=m.Get(r,this._lights,d.light),u=s.name||a.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,s.type){case"directional":{const h=new C(u,n.Backward(),this._loader.babylonScene);h.position.setAll(0),o=h;break}case"point":{o=new c(u,n.Zero(),this._loader.babylonScene);break}case"spot":{const h=new T(u,n.Zero(),n.Backward(),0,1,this._loader.babylonScene);h.angle=(s.spot&&s.spot.outerConeAngle||Math.PI/4)*2,h.innerAngle=(s.spot&&s.spot.innerConeAngle||0)*2,o=h;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${r}: Invalid light type (${s.type})`)}o._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,s._babylonLight=o,o.falloffType=_.FALLOFF_GLTF,o.diffuse=s.color?p.FromArray(s.color):p.White(),o.intensity=s.intensity==null?1:s.intensity,o.range=s.range==null?Number.MAX_VALUE:s.range,o.parent=a,this._loader._babylonLights.push(o),g.AddPointerMetadata(o,r),e(a)})))}}P(f);S(f,!0,l=>new x(l));export{x as KHR_lights};
